<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta http-equiv="X-UA-Compatible" content="ie=edge"><link rel="stylesheet" href="../lib/bulma.min.css"><link rel="stylesheet" href="../lib/font-awesome-4.7.0/css/font-awesome.min.css"><link rel="stylesheet" href="../lib/prism.css"><link rel="icon" href="../img/page-icon.png"><meta property="og:type" content="website"><meta property="og:site_name" content="INFO Tutorials"><meta property="og:title" content="Functional Programming in JavaScript"><meta property="og:description" content="Sorting, Filtering, Mapping, and Reducing"><meta property="og:image" content="https://drstearns.github.io/tutorials/img/page-icon.png"><title>Functional Programming in JavaScript</title><style>.is-funky{background-image:linear-gradient(to right,#006064,#880E4F)}.is-funky .subtitle,.is-funky .title{color:#fff}.screenshot{border:1px dotted #ccc;padding:10px;margin-bottom:1em}.bookmark-link{color:#ddd;margin-left:.25em}.home-link{color:#eee}.home-link:hover{color:#fff}.byline{font-size:.85rem;font-style:italic}.shaded{background-color:#eee}</style></head><body><header><div class="hero is-funky"><div class="hero-body"><div class="container"><div class="columns is-mobile"><div class="column"><h1 class="title">Functional Programming in JavaScript</h1><p class="subtitle">Sorting, Filtering, Mapping, and Reducing</p></div><div class="column is-narrow"><a href=".." class="home-link"><span class="icon is-medium"><i class="fa fa-home" aria-hidden="true" aria-label="back to table of contents"></i></span></a></div></div></div></div></div></header><main class="section"><div class="container"><div class="content"><p class="byline">Last edited on Jan 21, 2018 by <a href="https://ischool.uw.edu/people/faculty/dlsinfo">Dave Stearns</a></p><p>Despite it's name, the JavaScript language was based more on <a href="https://en.wikipedia.org/wiki/Scheme_(programming_language)">Scheme</a> than it was on Java. Scheme is functional programming language, which is a very different programming paradigm than object-oriented programming. This tutorial will introduce you to what functional programming is all about, and how you can unlock JavaScript's functional programming features.</p><blockquote><p><strong>WARNING:</strong> this tutorial assumes you already read the <a href="../javascript/">Introduction to JavaScript</a> tutorial. If you didn't, you should read it before continuing.</p></blockquote><h2 id="secwhatisfunctionalprogramming">What Is Functional Programming?</h2><p>Functional programming is a style of programming that differs from the object-oriented style you might have learned in your introductory computer science courses. In object-oriented programming, we construct programs by modeling the data we will manipulate as a series of interconnected objects, each of which manages some piece of the overall program state. These objects then send messages to each other (i.e., invoke methods) to mutate the state held by each object. The inputs to the program define the initial state (e.g., a file to edit), and the final outputs are the mutated state that is often persisted somewhere (e.g., written back to a file).</p><p>In functional programming, we construct programs by combining small, reusable, "pure" functions that transform data. These pure functions have the following qualities:</p><ul><li>they operate only on their inputs, and make no reference to other data (e.g., variables at a higher scope)</li><li>they never modify their inputs—instead, they always return new data or a reference to unmodified inputs</li><li>they have no side effects outside of their outputs (e.g., they never modify variables at a higher scope)</li><li>because of these previous rules, they always return the same outputs for the same inputs</li></ul><p>A functional program sends its initial input state through a series of these pure functions, much like a plumbing system sends water through a series of pipes, filters, valves, splitters, heaters, coolers, and pumps. The outputs of the final function become the program's outputs, which are often passed on to another program or persisted.</p><p>Advocates of functional programming note that pure functions are easier to test and reason about. Since they have no side-effects, you can simply test all possible classes of inputs and verify that you get the correct outputs. If all of your pure functions are well-tested, you can then combine them together to create highly-predictable and reliable programs.</p><p>These advocates also argue that functional programs are easier to read and reason about because they end up looking more <a href="../javascript/#secimperativevsdeclarative">declarative than imperative</a>. A functional program reads like a series of data transformations, the output of each flowing into the next as input. This will become easier to see as I show examples in the next section.</p><p>Although some functional programming zealots would argue that all programs should be written in a functional style, it's better to think of functional programming as another tool in your toolbox that is appropriate for some jobs, and not so much for others. Object-oriented programming is often the better choice for long-running, highly-interactive client programs, while functional is a better choice for short-lived programs or servers that handle discrete transactions. It's also possible to combine the two styles: for example, React components can be either object-oriented or functional, and you often use some functional techniques within object-oriented components.</p><h2 id="secfunctionalprogramminginjavascript">Functional Programming in JavaScript</h2><p>This is all a bit abstract so far, so let's see what this really looks like in practice. Functional programs operate on data, so we will use the following data file as input to our program.</p><blockquote><p><a href="https://faculty.washington.edu/dlsinfo/data/babynames_2016.js">https://faculty.washington.edu/dlsinfo/data/babynames_2016.js</a></p></blockquote><p>The data includes counts for all distinct <a href="https://www.ssa.gov/oact/babynames/limits.html">baby names registered with the Social Security Administration (SSA) during 2016</a>. The file defines one constant named <code>BABYNAMES</code>, which is set to an array of 32,868 objects. Each object in the array has the following properties:</p><ul><li><code>name</code>: a first name</li><li><code>sex</code>: a reported sex (the SSA allows only <code>M</code> or <code>F</code> for this field)</li><li><code>count</code>: the number of babies registered in 2016 with that name and reported sex</li></ul><p>For privacy reasons, baby names with fewer than 5 registrations are omitted from this set. Also note that <code>sex</code> refers to biological sex, not gender, and the SSA limits responses to only male or female.</p><p>If you include this file in your web page, it will define this constant in the global scope, and your code can then reference it using the name <code>BABYNAMES</code>. For example the code <code>BABYNAMES.length;</code> will return the length of the array (32,868).</p><h3 id="secfiltering">Filtering</h3><p>The first thing we might want to do with this array is extract just the objects that meet a particular criteria. For example, we might want to extract the objects where <code>sex === "M"</code> or <code>sex === "F"</code> into separate arrays so that we can process the male names separately from the female names. To do this, we first need a few functions that test whether the <code>sex</code> property of a given record is set to <code>"M"</code> or <code>"F"</code>.</p><pre class="language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">isMale</span><span class="token punctuation">(</span>record<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> record<span class="token punctuation">.</span>sex <span class="token operator">===</span> <span class="token string">"M"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">isFemale</span><span class="token punctuation">(</span>record<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> record<span class="token punctuation">.</span>sex <span class="token operator">===</span> <span class="token string">"F"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>Both of these are "pure" functions. They operate only on their inputs, they don't modify those inputs, and they don't have any side-effects. If you hand these functions the same object, they will always return the same results.</p><p>We can then use these functions with the built-in <code>.filter()</code> method that is available on all JavaScript arrays:</p><pre class="language-javascript"><code class="language-javascript"><span class="token keyword">let</span> females <span class="token operator">=</span> BABYNAMES<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>isFemale<span class="token punctuation">)</span><span class="token punctuation">;</span>
females<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// => 18757</span>
<span class="token keyword">let</span> males <span class="token operator">=</span> BABYNAMES<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>isMale<span class="token punctuation">)</span><span class="token punctuation">;</span>
males<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// => 14111</span></code></pre><p>The <code>.filter()</code> method takes a function (known as a <strong>predicate function</strong>) as a parameter. It calls that function once for each element in the array, passing that element as the first parameter to the predicate function. If your predicate function returns a <a href="../javascript/#secbooleanexpressionsandtruthiness">truthy value</a>, the element will be included in the output array. If your predicate function returns a falsy value, the element won't be included.</p><p>To make this more clear, here is what the body of <code>.filter()</code> looks like:</p><pre class="language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//assume `this` is the array upon which .filter() was called</span>
<span class="token comment" spellcheck="true">//and `test` is the function passed to .filter() as the first parameter</span>
<span class="token keyword">let</span> output <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//the array that will be returned</span>
<span class="token comment" spellcheck="true">//loop over all elements in the source array</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> elem <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//if the test functions returns something truthy...</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">test</span><span class="token punctuation">(</span>elem<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//...add the element to the output array</span>
        output<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>elem<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">//return the output array</span>
<span class="token keyword">return</span> output<span class="token punctuation">;</span></code></pre><p>As you can see, the <code>.filter()</code> method separates the task of iterating over the array from the task of testing whether each element should be included in the output array. The <code>.filter()</code> method supplies the first, but delegates the second to the predicate function you pass to it. That predicate function can be as complex as it needs to be, and the <code>.filter()</code> method doesn't have to care about its details.</p><p>Note that the <code>.filter()</code> method is also a pure function: it doesn't modify the array upon which it was called. Instead, it returns a new array containing only the objects that passed the predicate function.</p><p>You may have noticed that the two filter predicate functions above (<code>isMale()</code> and <code>isFemale()</code>) are very similar: the only real difference is what value they compare the <code>.sex</code> property to. Whenever you see something like this, you should ask yourself, "is there a way I can do this with just one function?" Indeed there is. Remember that if you declare a function inside another function, it creates a <a href="../javascript/#secclosures">closure</a>, which allows the inner function to reference parameters and local variables defined in the outer function. So we could write one function that takes the value to compare against as a parameter, and returns a new predicate function one could use with the <code>.filter()</code> method.</p><pre class="language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//returns a filter predicate function that </span>
<span class="token comment" spellcheck="true">//compares the .sex property to the value </span>
<span class="token comment" spellcheck="true">//passed as the `sex` parameter</span>
<span class="token keyword">function</span> <span class="token function">isSex</span><span class="token punctuation">(</span>sex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//return a new filter test function that...</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span>record<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//...compares the .sex property to the </span>
        <span class="token comment" spellcheck="true">//sex parameter value</span>
        <span class="token keyword">return</span> record<span class="token punctuation">.</span>sex <span class="token operator">===</span> sex<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">//use isSex() to create separate </span>
<span class="token comment" spellcheck="true">//male/female filter predicate functions</span>
<span class="token keyword">let</span> isMale <span class="token operator">=</span> <span class="token function">isSex</span><span class="token punctuation">(</span><span class="token string">"M"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> isFemale <span class="token operator">=</span> <span class="token function">isSex</span><span class="token punctuation">(</span><span class="token string">"F"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//use those filter functions</span>
<span class="token keyword">let</span> females <span class="token operator">=</span> BABYNAMES<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>isFemale<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>This code looks a bit more complicated than before, but now we've isolated the way we test the <code>.sex</code> property to just one function, and we don't have to duplicate that for each distinct sex. If we discover later on that the data contains both upper and lower-case letters for that field, we can make the adjustment to just one line of code and handle all of the cases. For example:</p><pre class="language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//returns a filter predicate function that </span>
<span class="token comment" spellcheck="true">//compares the .sex property to the value </span>
<span class="token comment" spellcheck="true">//passed as the `sex` parameter</span>
<span class="token keyword">function</span> <span class="token function">isSex</span><span class="token punctuation">(</span>sex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//convert parameter to lower case for a </span>
    <span class="token comment" spellcheck="true">//case-insensitive comparison</span>
    <span class="token keyword">let</span> sexLower <span class="token operator">=</span> sex<span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//return a new filter test function that...</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span>record<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//...compares the lower-cased .sex property</span>
        <span class="token comment" spellcheck="true">//to the lower-cased sex parameter value</span>
        <span class="token keyword">return</span> record<span class="token punctuation">.</span>sex<span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">===</span> sexLower
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>And if the SSA ever started allowing a value of <code>"U"</code> for unknown or unspecified, we could easily create a new filter predicate function without having to duplicate code.</p><h3 id="seccombiningfunctions">Combining Functions</h3><p>So far we are filtering on only one property, but what if we wanted to filter for male baby names that have a count under 100? We could write a filter predicate function specifically for that, but if we then want to the same thing for female baby names, we'd have to duplicate that with only a small change. Or we could embrace functional programming and realize that this predicate is a combination of two simpler predicates that are useful on their own: <code>isMale()</code> and <code>countUnder100()</code>. We could write one function that combines two existing predicate functions, regardless of what those predicate functions happen to test, using AND logic.</p><pre class="language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//returns true if count is less than 100</span>
<span class="token keyword">function</span> <span class="token function">countUnder100</span><span class="token punctuation">(</span>record<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> record<span class="token punctuation">.</span>count <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">//returns a new filter predicate that combines</span>
<span class="token comment" spellcheck="true">//the two predicate function parameters using &amp;&amp;</span>
<span class="token keyword">function</span> <span class="token function">and</span><span class="token punctuation">(</span>predicate1<span class="token punctuation">,</span> predicate2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span>record<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">predicate1</span><span class="token punctuation">(</span>record<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">predicate2</span><span class="token punctuation">(</span>record<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">//create new predicate functions combining</span>
<span class="token comment" spellcheck="true">//existing predicate functions with AND logic</span>
<span class="token keyword">let</span> isMaleUnder100 <span class="token operator">=</span> <span class="token function">and</span><span class="token punctuation">(</span>isMale<span class="token punctuation">,</span> countUnder100<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> isFemaleUnder100 <span class="token operator">=</span> <span class="token function">and</span><span class="token punctuation">(</span>isFemale<span class="token punctuation">,</span> countUnder100<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//use them</span>
<span class="token keyword">let</span> malesWithLowCounts <span class="token operator">=</span> BABYNAMES<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>isMaleUnder100<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Now you can create filter predicates that are combinations of <em>any</em> two existing predicate functions, including predicates returned from the <code>and()</code> function. You could of course implement an <code>or()</code> function as well that used <code>||</code> instead of <code>&amp;&amp;</code>. You could also extend these to handle more than just two predicates at a time, but we need to learn a few other techniques before we can do that.</p><blockquote><p><strong>NOTE:</strong> Although you can implement functions like this yourself, there are several functional programming JavaScript libraries that already implement generic function combiners like these. See the <a href="#secfunctionalprogramminglibraries">Functional Programming Libraries section</a> at the end for links to these libraries.</p></blockquote><p>Lastly, you might already be thinking that the <code>countUnder100()</code> function is too specific, and could easily be converted to a more generic <code>countUnder()</code> function that takes the upper threshold number as a parameter, and returns a new predicate function. You'd be right:</p><pre class="language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">countUnder</span><span class="token punctuation">(</span>amount<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span>record<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> record<span class="token punctuation">.</span>count <span class="token operator">&lt;</span> amount<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> countUnder100 <span class="token operator">=</span> <span class="token function">countUnder</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> isMaleUnder100 <span class="token operator">=</span> <span class="token function">and</span><span class="token punctuation">(</span>isMale<span class="token punctuation">,</span> countUnder100<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>This approach to combining functions is central to functional programming. It's like building with Legos: the smallest pieces do just one simple and general thing, and you then combine those together to create more specific and sophisticated structures.</p><h3 id="secsorting">Sorting</h3><p>Now that we have the ability to filter arrays, we next might want to sort those filtered sets. We already saw a bit of sorting in the <a href="../javascript/#secpassingfunctionstofunctions">JavaScript Tutorial</a>, but let's quickly review how that works. Every JavaScript array has a <code>.sort()</code> method, which takes a function (known as a <strong>comparator</strong>) that compares two of the array elements. The comparator function should return a negative number if the first element is less than the second, a zero if they are equal, and a positive number if the first is greater than the second. For example, if we wanted to sort an array of these baby name objects by their <code>count</code> property ascending, the comparator function would look like this:</p><pre class="language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">byCount</span><span class="token punctuation">(</span>record1<span class="token punctuation">,</span> record2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> record1<span class="token punctuation">.</span>count <span class="token operator">-</span> record2<span class="token punctuation">.</span>count<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>And a comparator that sorts by the <code>name</code> property would use the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare"><code>.localeCompare()</code> method</a>, which is on every string:</p><pre class="language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">byName</span><span class="token punctuation">(</span>record1<span class="token punctuation">,</span> record2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> record1<span class="token punctuation">.</span>name<span class="token punctuation">.</span><span class="token function">localeCompare</span><span class="token punctuation">(</span>record2<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>Now that we have these two functions, we can sort any array of these baby names (filtered or not) by these properties. Remember that <code>.filter()</code> returns a new array, and since every array has a <code>.sort()</code> method, we can simply chain the call to <code>.sort()</code> on the end of the call to <code>.filter()</code>:</p><pre class="language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//extract all the male names and sort by count ascending</span>
<span class="token keyword">let</span> sortedMales <span class="token operator">=</span> BABYNAMES<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>isMale<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>byCount<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">//same thing for female names</span>
<span class="token keyword">let</span> sortedFemales <span class="token operator">=</span> BABYNAMES<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>isFemale<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>byCount<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><blockquote><p><strong>WARNING:</strong> the <code>.sort()</code> method isn't pure—it actually sorts the array in place and returns a reference to the original array. This is why you'll often see developers filter or map the array first to create a copy of the original array before sorting it. See the <a href="#secmapping">Mapping section</a> below for an explanation of mapping.</p></blockquote><p>But what if we want these sorted descending by count instead of ascending? You might be tempted to write more comparator functions, but the combinations would start to explode. Instead, let's embrace functional programming and realize that a descending sort requires a comparator that simply negates the return value of the ascending comparator: if the ascending comparator returns a negative number, our descending comparator needs to flip that to a positive number, and vice-versa. Thankfully <code>-0 === 0</code> in JavaScript, so negating a zero won't hurt anything. We can write this descending comparator as a function that takes another comparator as a parameter and returns a new comparator that negates the result:</p><pre class="language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//`comparator` is a sort comparator function</span>
<span class="token keyword">function</span> <span class="token function">descending</span><span class="token punctuation">(</span>comparator<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//return a new comparator that...</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span>record1<span class="token punctuation">,</span> record2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//...negates the result of `comparator()`</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token function">comparator</span><span class="token punctuation">(</span>record1<span class="token punctuation">,</span> record2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>Now we can wrap any existing comparator with <code>descending()</code> to get a descending rather than ascending sort:</p><pre class="language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//create a descending version of our byCount comparator</span>
<span class="token keyword">let</span> byCountDescending <span class="token operator">=</span> <span class="token function">descending</span><span class="token punctuation">(</span>byCount<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">//extract all the male names and sort by count descending</span>
<span class="token keyword">let</span> sortedMales <span class="token operator">=</span> BABYNAMES<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>isMale<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>byCountDescending<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Notice how our program is starting to look more like a declarative series of high-level operations rather than an imperative series of low-level commands. The data flow through these high-level operations and the output of the last one becomes the output of our program.</p><p>Now what if we want to sort by name <em>within</em> count? That is, we want the overall array ordered by <code>count</code>, but when there are a bunch of records that all have the same value for <code>count</code>, we want those ordered by <code>name</code>. This is known as a multi-key sort, and we can enable this with just one additional function:</p><pre class="language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//`comparator1` and `comparator2` are both sort comparator functions</span>
<span class="token keyword">function</span> <span class="token function">multiKey</span><span class="token punctuation">(</span>comparator1<span class="token punctuation">,</span> comparator2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//return a new comparator that...</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span>record1<span class="token punctuation">,</span> record2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//...runs comparator1 and if the result is 0...</span>
        <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token function">comparator1</span><span class="token punctuation">(</span>record1<span class="token punctuation">,</span> record2<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">//...returns the result of comparator2 instead</span>
            <span class="token keyword">return</span> <span class="token function">comparator2</span><span class="token punctuation">(</span>record1<span class="token punctuation">,</span> record2<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> result<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>Like the <code>and()</code> function earlier, this function returns a new comparator that combines two existing comparators. It runs the first comparator and if the result is <code>0</code> (i.e., the two records are considered equal to each other), it returns the results of the second comparator instead. This will cause the array to be sorted by the first comparator overall, but then by the second comparator within common values for the first.</p><p>To sort males by name ascending <em>within</em> count descending, the code would look like this:</p><pre class="language-javascript"><code class="language-javascript"><span class="token keyword">let</span> byCountDescending <span class="token operator">=</span> <span class="token function">descending</span><span class="token punctuation">(</span>byCount<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> byNameWithinCount <span class="token operator">=</span> <span class="token function">multiKey</span><span class="token punctuation">(</span>byCountDescending<span class="token punctuation">,</span> byName<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> malesByNameWithinCount <span class="token operator">=</span> BABYNAMES<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>isMale<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>byNameWithinCount<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Of course, you could make this all one line without creating intermediate variables, but the readability would start to suffer. Remember that one of the goals of functional programming is to create code that is easier to read and reason about. If each statement solves only one piece of the overall puzzle, it's easy to see how the whole puzzle comes together.</p><h3 id="secslicing">Slicing</h3><p>After filtering and sorting, it's common to slice off only the top or bottom elements from the array. Every JavaScript array has a built-in <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice">slice() method</a> that does exactly this. For example, say we want just the top 10 female baby names. We already have all the filtering and sorting functions we need, so we just need to add a final <code>.slice()</code>:</p><pre class="language-javascript"><code class="language-javascript"><span class="token keyword">let</span> top10Females <span class="token operator">=</span> BABYNAMES<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>isFemale<span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>byCountDescending<span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>The <code>.slice()</code> method takes two parameters: the array index to start at, and the array index to go up to but not include. So <code>.slice(0,10)</code> will return a new array containing elements <code>0</code> through <code>9</code>, which are the first 10 elements in the array. Since we filtered for only female names and then sorted by count descending, those first 10 elements are the female names with the highest counts.</p><h3 id="secmapping">Mapping</h3><p>Another common operation that you will want to do on arrays of data is mapping. A mapping operation transforms each element of the array by passing that array element through a function you provide (known as a <strong>transformer</strong>). This is best explained through some concrete examples.</p><pre class="language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">addOne</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> value <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> evens <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
evens<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>addOne<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// => [1,3,5,7,9,11]</span></code></pre><p>The <code>.map()</code> method in this example will create a new array for the outputs that is the same size as the input array, call the <code>addOne()</code> function once for each element in the <code>events</code> array, and put the returned value into the output array at the same position. After mapping all of the elements, it returns the output array. The body of the <code>.map()</code> method looks something like this:</p><pre class="language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//assume `this` is the array upon which .map() is called</span>
<span class="token comment" spellcheck="true">//and `transform` is the function passed to .map()</span>

<span class="token comment" spellcheck="true">//create an output array of the same length</span>
<span class="token keyword">let</span> output <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//send each element through the transform</span>
    <span class="token comment" spellcheck="true">//function and put the result into the output </span>
    <span class="token comment" spellcheck="true">//array at the same position</span>
    output<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">transform</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">return</span> output<span class="token punctuation">;</span></code></pre><p>It's actually pretty simple and straightforward. Each element is passed through the transformer function you pass to <code>.map()</code> and whatever that function returns is put into the output array at the same index.</p><p>This can be used to transform elements in all sorts of ways. For example, say we have an array of strings and we want to make them all lower-case:</p><pre class="language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">toLower</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> str<span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> values <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"John"</span><span class="token punctuation">,</span><span class="token string">"Mary"</span><span class="token punctuation">,</span><span class="token string">"Peter"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
values<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>toLower<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// => ["john","mary","peter"]</span></code></pre><p>But we can also use this to transform elements in more substantial ways. For example, say we have an array of those baby name objects and we want to extract just the <code>name</code> property from each. In other words, we want to end up with an array of strings instead of an array of objects. We can do that with <code>.map()</code> as well.</p><pre class="language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//returns just the `name` property</span>
<span class="token keyword">function</span> <span class="token function">pluckName</span><span class="token punctuation">(</span>record<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> record<span class="token punctuation">.</span>name<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> top10FemaleNames <span class="token operator">=</span> BABYNAMES<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>isFemale<span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>byCountDescending<span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>pluckName<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Because we ran each element of the filtered, sorted, and sliced array through the <code>pluckName()</code> function, the <code>top10FemaleNames</code> variable will be set to an <em>array of strings</em> containing just the top 10 female baby names. We transformed entire objects into just strings using the <code>pluckName()</code> function. If you print <code>top10FemaleNames</code> to the console, you'll get this:</p><pre class="language-json"><code class="language-json"><span class="token punctuation">[</span><span class="token string">"Emma"</span><span class="token punctuation">,</span> <span class="token string">"Olivia"</span><span class="token punctuation">,</span> <span class="token string">"Ava"</span><span class="token punctuation">,</span> <span class="token string">"Sophia"</span><span class="token punctuation">,</span> <span class="token string">"Isabella"</span><span class="token punctuation">,</span> <span class="token string">"Mia"</span><span class="token punctuation">,</span> <span class="token string">"Charlotte"</span><span class="token punctuation">,</span> <span class="token string">"Abigail"</span><span class="token punctuation">,</span> <span class="token string">"Emily"</span><span class="token punctuation">,</span> <span class="token string">"Harper"</span><span class="token punctuation">]</span></code></pre><p>Those were the top 10 female baby names registered with the SSA during 2016!</p><p>As you might expect, we can make <code>pluckName()</code> more generic by creating a function that returns a transformer that plucks <em>any</em> property from an object given a property name.</p><pre class="language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//`propName` is a string</span>
<span class="token keyword">function</span> <span class="token function">pluck</span><span class="token punctuation">(</span>propName<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//return a transformer that...</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span>record<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//...returns just the requested property</span>
        <span class="token keyword">return</span> record<span class="token punctuation">[</span>propName<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">//now we can pluck any property by name!</span>
<span class="token keyword">let</span> pluckName <span class="token operator">=</span> <span class="token function">pluck</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> pluckCount <span class="token operator">=</span> <span class="token function">pluck</span><span class="token punctuation">(</span><span class="token string">"count"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Transformer functions can transform their inputs in any way they want. In fact, a transformer could return an entirely new object, or even a function that makes use of the input. This makes mapping a very powerful technique.</p><h3 id="secreducing">Reducing</h3><p>The last functional technique I will discuss in this tutorial is also the hardest to understand: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce">reducing</a>. While mapping transforms each element into an array of the same size as the input array, reducing reduces the elements of an array to a single value. This value could be a primitive value (number, string, boolean) or it could be a complex type like an object, a smaller array, or even a function.</p><p>A simple example will illustrate what I mean:</p><pre class="language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//returns the sum of `accumulator` and `num`</span>
<span class="token keyword">function</span> <span class="token function">sum</span><span class="token punctuation">(</span>accumulator<span class="token punctuation">,</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> accumulator <span class="token operator">+</span> num<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">//create an array of a few numbers</span>
<span class="token keyword">let</span> nums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//calculate the sum of all the numbers</span>
nums<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span>sum<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// => 15</span></code></pre><p>The <code>.reduce()</code> method takes two parameters: a function, known as a <strong>reducer</strong>, and a starting value, known as the <strong>accumulator</strong>. The <code>.reduce()</code> method calls the reducer once for each element in the array, passing the current value of the accumulator as the first parameter, and the current array element as the second parameter. It resets the accumulator to whatever the reducer function returns, and continues processing the next element in the array.</p><p>The body of <code>.reduce()</code> would look something like this:</p><pre class="language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//assume `this` is the array upon which .reduce() is called</span>
<span class="token comment" spellcheck="true">//and `reducer` is the function passed to .reduce() as the first parameter</span>
<span class="token comment" spellcheck="true">//and `accumulator` is the initial value passed as the second parameter</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    accumulator <span class="token operator">=</span> <span class="token function">reducer</span><span class="token punctuation">(</span>accumulator<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">return</span> accumulator<span class="token punctuation">;</span></code></pre><p>Note how simple, yet elegant this is. Your reducer gets the current accumulator value and the current element. Whatever your reducer returns becomes the new accumulator value. At the end, it returns the final accumulator.</p><p>Summing numbers is only one example of how you might use <code>.reduce()</code>. Finding the minimum or maximum value in the array is another classic application of this method. We could sort the array and then slice off the first or last element, but it would be much more efficient to use reduce to do only one pass through the array:</p><pre class="language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">max</span><span class="token punctuation">(</span>n1<span class="token punctuation">,</span> n2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//ternary conditional--see Intro to JavaScript tutorial for details</span>
    <span class="token keyword">return</span> n2 <span class="token operator">></span> n1 <span class="token operator">?</span> n2 <span class="token punctuation">:</span> n1<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

nums<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span>max<span class="token punctuation">,</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Here we use our <code>max()</code> function as the reducer, and the first element in the array as the starting accumulator. Each time <code>.reduce()</code> calls our <code>max()</code> function, it passes the current accumulator value and the current element. Our function returns the greater of the two, which becomes the current accumulator. When it's all done, the accumulator is set to the maximum value.</p><p>The term "accumulator" is intentionally vague. This value can be of any type, and you can use it however you want in your reducer functions. For example, the accumulator could be a JavaScript object where the keys are all the distinct strings in an array, and the values associated with those keys are the number of times that distinct string appears in the array. For example:</p><pre class="language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//`nameMap` is a JavaScript object</span>
<span class="token comment" spellcheck="true">//`name` is a string array element</span>
<span class="token keyword">function</span> <span class="token function">countDistinct</span><span class="token punctuation">(</span>nameMap<span class="token punctuation">,</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//if the object doesn't have a key for</span>
    <span class="token comment" spellcheck="true">//the name yet, add one with a value of 0</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>nameMap<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        nameMap<span class="token punctuation">[</span>name<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">//increment the count associated with this name</span>
    nameMap<span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//return the map</span>
    <span class="token keyword">return</span> nameMap<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> names <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"Dave"</span><span class="token punctuation">,</span> <span class="token string">"Mary"</span><span class="token punctuation">,</span> <span class="token string">"John"</span><span class="token punctuation">,</span> <span class="token string">"Dave"</span><span class="token punctuation">,</span> <span class="token string">"Mary"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
names<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span>countDistinct<span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// => {Dave: 2, Mary: 2, John: 1}</span></code></pre><p>The initial accumulator value we pass here is an empty object <code>{}</code>. This gets passed into our <code>countDistinct()</code> method as the first parameter, which we called <code>nameMap</code> (you can call it whatever you want, it's your parameter after all). If the name map doesn't contain a key matching the current array element, we add it with the value of <code>0</code>. We then increment the value associated with that key and return the map as the next accumulator. By the end, we get a JavaScript object with a key for each distinct string in the array, and the value associated with each of those keys is the number of times that string was in the array.</p><h2 id="secfunctionalprogramminglibraries">Functional Programming Libraries</h2><p>This tutorial has introduced you to a few of the functional programming methods that are built-in to all JavaScript arrays, but these methods only scratch the surface of what a full functional programming library provides. If you're interested in doing more serious functional programming, check out these libraries.</p><ul><li><a href="https://lodash.com/">Lodash</a> and the more pure variant <a href="https://github.com/lodash/lodash/wiki/FP-Guide">lodash/fp</a></li><li><a href="http://ramdajs.com/">Ramda</a></li><li><a href="http://danieltao.com/lazy.js/">Lazy.js</a></li></ul><p>Finally, I would remiss if I didn't acknowledge that <a href="https://hackernoon.com/functional-programming-in-javascript-is-an-antipattern-58526819f21e">not everyone thinks functional programming in JavaScript is a good idea</a>. Although JavaScript was based more on Scheme than Java, there are a lot of elements in the language where they break the functional paradigm (e.g., <code>.sort()</code> not being pure). Many client-side developers who have gotten serious about functional programming have turned to other languages that were designed as functional languages from the start, but can still compile to JavaScript. Here are some of the currently-popular choices:</p><ul><li><a href="https://clojure.org/">Clojure</a> and the <a href="https://github.com/clojure/clojurescript">ClojureScript compiler for JavaScript</a></li><li><a href="https://www.haskell.org/">Haskell</a> and one of the several <a href="https://wiki.haskell.org/The_JavaScript_Problem">Haskell to JS compilers</a></li><li><a href="http://elm-lang.org/">Elm</a>, which has a built-in compiler to JavaScript</li></ul></div></div></main><footer class="footer"><div class="container"><div class="content"><p>Created by <a href="https://ischool.uw.edu/people/faculty/dlsinfo">Dave Stearns</a>, <a href="https://ischool.uw.edu">The Information School</a>, <a href="https://uw.edu">University of Washington</a></p><p><a href=".."><span class="icon"><i class="fa fa-home"></i> </span>back to contents</a></p></div></div></footer><script>var headings=document.querySelectorAll("h2,h3,h4,h5");headings.forEach(function(e){var a=document.createElement("a");a.textContent="#",a.href="#"+e.id,a.classList.add("bookmark-link"),e.appendChild(a)})</script><script>!function(e,t,a,n,c,o,s){e.GoogleAnalyticsObject=c,e[c]=e[c]||function(){(e[c].q=e[c].q||[]).push(arguments)},e[c].l=1*new Date,o=t.createElement(a),s=t.getElementsByTagName(a)[0],o.async=1,o.src="https://www.google-analytics.com/analytics.js",s.parentNode.insertBefore(o,s)}(window,document,"script",0,"ga"),ga("create","UA-102177301-1","auto"),ga("send","pageview")</script></body></html>