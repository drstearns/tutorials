<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta http-equiv="X-UA-Compatible" content="ie=edge"><link rel="stylesheet" href="../lib/bulma.min.css"><link rel="stylesheet" href="../lib/font-awesome-4.7.0/css/font-awesome.min.css"><link rel="stylesheet" href="../lib/prism.css"><link rel="icon" href="../img/page-icon.png"><meta property="og:type" content="website"><meta property="og:site_name" content="INFO Tutorials"><meta property="og:title" content="Tokenizing HTML Streams in Go"><meta property="og:description" content="Efficiently extracting information from fetched web pages"><meta property="og:image" content="https://drstearns.github.io/tutorials/img/page-icon.png"><title>Tokenizing HTML Streams in Go</title><style>.is-funky{background-image:linear-gradient(to right,#006064,#880E4F)}.is-funky .subtitle,.is-funky .title{color:#fff}.screenshot{border:1px dotted #ccc;padding:10px}.bookmark-link{color:#ddd;margin-left:.25em}.home-link{color:#eee}.home-link:hover{color:#fff}.byline{font-size:.85rem;font-style:italic}.shaded{background-color:#eee}</style></head><body><header><div class="hero is-funky"><div class="hero-body"><div class="container"><div class="columns is-mobile"><div class="column"><h1 class="title">Tokenizing HTML Streams in Go</h1><p class="subtitle">Efficiently extracting information from fetched web pages</p></div><div class="column is-narrow"><a href=".." class="home-link"><span class="icon is-medium"><i class="fa fa-home" aria-hidden="true" aria-label="back to table of contents"></i></span></a></div></div></div></div></div></header><main class="section"><div class="container"><div class="content"><p class="byline">Last edited on Jul 17, 2017 by <a href="https://ischool.uw.edu/people/faculty/dlsinfo">Dave Stearns</a></p><p>Go makes it really easy to build not only HTTP servers, but also HTTP clients. That is, you can quickly write programs that make HTTP requests and process the results. If the results are HTML, Go also makes it rather easy to tokenize that HTML and examine the results.</p><h2 id="seccreateasimplegoprogram">Create a Simple Go Program</h2><p>To show you how this all works, let's create a program that will fetch some HTML and extract the value of its <code>&lt;title&gt;</code> element.</p><p>Create a new directory within your <code>$GOPATH/src</code> directory named <code>pagetitle</code>. Inside that directory create a file named <code>main.go</code> and add this basic Go program boilerplate to it:</p><pre class="language-go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

<span class="token punctuation">}</span></code></pre><p>We could hard-code a URL here, but our program would be much more versatile if we read the URL from a command-line argument. Those are available via the <code>os.Args</code> slice. The first element in the slice is the command used to execute your program, so the first parameter is actually at <code>os.Args[1]</code>. If the user doesn't supply that parameter, we should describe how to use the program and exit with a non-zero code, which indicates an error happened:</p><pre class="language-go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
    <span class="token string">"fmt"</span>
    <span class="token string">"os"</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//if the caller didn't provide a URL to fetch...</span>
    <span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>Args<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">2</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//print the usage and exit with an error</span>
        fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"usage:\n  pagetitle &lt;url>\n"</span><span class="token punctuation">)</span>
        os<span class="token punctuation">.</span><span class="token function">Exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    URL <span class="token operator">:=</span> os<span class="token punctuation">.</span>Args<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span></code></pre><p>You might be wondering why I used <code>URL</code> for the variable name here rather than <code>url</code>. There are two reasons. The first is that there is a Go standard library package named <code>url</code>, so it's best to avoid using that as a variable name. If you try to import the <code>url</code> package later (say to parse a URL into its component parts), your local variable will shadow the variable created by the imported package, and you won't be able to access the package's functions while your local variable is still in scope.</p><p>The second reason is that Go is very opinionated about code style. Their style rules say that acronyms in variable names should be in uppercase. If you create a variable name <code>myUrl</code>, the go linter will generate a warning saying that <code>myUrl</code> should be <code>myURL</code>.</p><h2 id="secfetchtheurl">Fetch the URL</h2><p>Now that we know what URL to fetch, it's time to do that. Thankfully, Go makes this ridiculous easy. Their <code>http</code> package has a <code>Get()</code> function that does exactly what we need:</p><pre class="language-go"><code class="language-go"><span class="token comment" spellcheck="true">//GET the URL</span>
resp<span class="token punctuation">,</span> err <span class="token operator">:=</span> http<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span>URL<span class="token punctuation">)</span>

<span class="token comment" spellcheck="true">//if there was an error, report it and exit</span>
<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//.Fatalf() prints the error and exits the process</span>
    log<span class="token punctuation">.</span><span class="token function">Fatalf</span><span class="token punctuation">(</span><span class="token string">"error fetching URL: %v\n"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">//make sure the response body gets closed</span>
<span class="token keyword">defer</span> resp<span class="token punctuation">.</span>Body<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>The <code>Get()</code> function returns a pointer to an <a href="https://golang.org/pkg/net/http/#Response">http.Response</a> struct and potentially an error. If the error is non-nil, it's generally best to assume that the response pointer will also be nil. So it's a very common pattern to check whether <code>err != nil</code>, and if it is, return the error to the caller. Since we are in the <code>main()</code> function still, we just use <code>log.Fatalf()</code> to print an error message and exit the process with an error code.</p><p>If there was no error, we have a valid response, and our <code>resp</code> variable will now hold all of the response information: status code, headers, and the content body. This body is an <code>io.ReadCloser</code>, which gives us a hint that we need to close this body stream before exiting our program. Here we use Go's <a href="https://gobyexample.com/defer">defer statement</a> to ensure that the <code>.Close()</code> method is called on the response body regardless of how we exit the current function.</p><p>In order for us to process this response as an HTML page, we still need to verify two things before proceeding:</p><ul><li>The status code == http.StatusOK (200)</li><li>The <code>Content-Type</code> header starts with <code>text/html</code></li></ul><p>If the user gave us a URL that doesn't match anything on the server, the server will respond with a <code>404 Not Found</code> error, and the response body won't be of any use to us. And if the user gave us a URL to something like an image or a CSS stylesheet, the response body won't parse as valid HTML. We can verify these things with a few checks:</p><pre class="language-go"><code class="language-go"><span class="token comment" spellcheck="true">//check response status code</span>
<span class="token keyword">if</span> resp<span class="token punctuation">.</span>StatusCode <span class="token operator">!=</span> http<span class="token punctuation">.</span>StatusOK <span class="token punctuation">{</span>
    log<span class="token punctuation">.</span><span class="token function">Fatalf</span><span class="token punctuation">(</span><span class="token string">"response status code was %d\n"</span><span class="token punctuation">,</span> resp<span class="token punctuation">.</span>StatusCode<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">//check response content type</span>
ctype <span class="token operator">:=</span> resp<span class="token punctuation">.</span>Header<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span><span class="token string">"Content-Type"</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> <span class="token operator">!</span>strings<span class="token punctuation">.</span><span class="token function">HasPrefix</span><span class="token punctuation">(</span>ctype<span class="token punctuation">,</span> <span class="token string">"text/html"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    log<span class="token punctuation">.</span><span class="token function">Fatalf</span><span class="token punctuation">(</span><span class="token string">"response content type was %s not text/html\n"</span><span class="token punctuation">,</span> ctype<span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre><p>The <code>strings</code> package offers a number of handy string-related functions. Here we use <code>HasPrefix()</code>, which returns true if the string passed as the first parameter starts with the string passed as the second parameter.</p><blockquote><p><strong>NOTE:</strong> we are using <code>log.Fatalf()</code> here because this is a command-line utility, and we want to exit the process in the event of an error. If you are fetching and tokenizing HTML in a web server, do not use log.Fatalf(), as exiting the process will stop your web server. Instead, handle errors by responding to your client using the <code>http.Error()</code> function. This writes the error to the client and leaves your server running.</p></blockquote><h2 id="sectokenizethehtml">Tokenize the HTML</h2><p>Now we are ready to tokenize the response HTML and extract the page title. If you are unfamiliar with that word 'tokenize', it's simply the process of breaking a stream of characters into discrete tokens defined by the particular grammarâ€”in this case, HTML. The tokens in HTML are start-tag (<code>&lt;tag&gt;</code>), self-closing tag (<code>&lt;tag/&gt;</code>), end-tag (<code>&lt;/tag&gt;</code>), and plain text content within an element.</p><p>Tokenizing is the first step to parsing the document into a tree of element and text nodes, like the DOM. That full tree is really helpful to a program like a web browser, which allows manipulation and re-rendering of the tree over time, but it comes at a cost: it consumes a lot of memory to construct all of those tree nodes, and we have to process the entire document, even if all we want is one element in the <code>&lt;head&gt;</code> section. It would be much more efficient to simply tokenize the page, looking for the <code>&lt;title&gt;</code> element in particular, and exit as soon as we find it.</p><p>HTML tokenizing and parsing isn't quite yet in the Go standard library, but the Go team has released <a href="https://godoc.org/golang.org/x/net/html">a "supplementary package" for this</a>. These supplementary packages typically become part of the standard library in a future release (e.g., the <code>context</code> package began as a supplementary one), but only after the Go team is satisfied with the API. Because they guarantee source-code backwards compatibility with each release, they add things to the standard library only when they are sure they can freeze the API.</p><p>But developers can start using the supplementary packages right away; the Go team actually encourages developers to do so and send them feedback. To get this supplementary HTML tokenizing and parsing package, use this command in your command-line terminal:</p><pre class="language-bash"><code class="language-bash">go get golang.org/x/net/html</code></pre><p>This will download the source code for the package to your <code>$GOPATH</code>, compile it, and install the resulting object file to your <code>$GOPATH/pkg</code> directory.</p><p>To use this package in our project, we need to import it. Add the package's import path to your <code>import</code> list:</p><pre class="language-go"><code class="language-go"><span class="token keyword">import</span> <span class="token punctuation">(</span>
    <span class="token string">"fmt"</span>
    <span class="token string">"io"</span>
    <span class="token string">"log"</span>
    <span class="token string">"net/http"</span>
    <span class="token string">"os"</span>
    <span class="token string">"strings"</span>

    <span class="token string">"golang.org/x/net/html"</span>
<span class="token punctuation">)</span></code></pre><p>Because the import path is the same thing you pass to <code>go get</code>, your dependencies are totally self-describing. If other developers clone your repo, all they need to do is execute <code>go get</code> with no arguments, and it will automatically download and install all imported packages.</p><p>Start by creating a new tokenizer over the response body:</p><pre class="language-go"><code class="language-go"><span class="token comment" spellcheck="true">//create a new tokenizer over the response body</span>
tokenizer <span class="token operator">:=</span> html<span class="token punctuation">.</span><span class="token function">NewTokenizer</span><span class="token punctuation">(</span>resp<span class="token punctuation">.</span>Body<span class="token punctuation">)</span></code></pre><p>If you look at <a href="https://godoc.org/golang.org/x/net/html#NewTokenizer">the package documentation</a>, the <code>NewTokenizer()</code> function actually takes an <code>io.Reader</code> interface. This allows the parser to work on any HTML stream that implements the very minimal <a href="https://golang.org/pkg/io/#Reader">io.Reader interface</a>. For example, it can tokenize HTML returned from an HTTP request, or read from a file, or fetched from a database: any source that satisfies the <code>io.Reader</code> interface.</p><p>The tokenizer has a <code>.Next()</code> method which returns just the next token type. You should call this in a loop that exits only when you find the <code>&lt;title&gt;</code> element, or after you encounter an error (including the end of the stream). Go's <code>for</code> loop handles this by simply omitting the start, comparison, and iteration expressions:</p><pre class="language-go"><code class="language-go"><span class="token comment" spellcheck="true">//loop until we find the title element and its content</span>
<span class="token comment" spellcheck="true">//or encounter an error (which includes the end of the stream)</span>
<span class="token keyword">for</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//get the next token type</span>
    tokenType <span class="token operator">:=</span> tokenizer<span class="token punctuation">.</span><span class="token function">Next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token comment" spellcheck="true">//if it's an error token, we either reached</span>
    <span class="token comment" spellcheck="true">//the end of the file, or the HTML was malformed</span>
    <span class="token keyword">if</span> tokenType <span class="token operator">==</span> html<span class="token punctuation">.</span>ErrorToken <span class="token punctuation">{</span>
        log<span class="token punctuation">.</span><span class="token function">Fatalf</span><span class="token punctuation">(</span><span class="token string">"error tokenizing HTML: %v"</span><span class="token punctuation">,</span> tokenizer<span class="token punctuation">.</span><span class="token function">Err</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">//if this is a start tag token...</span>
    <span class="token keyword">if</span> tokenType <span class="token operator">==</span> html<span class="token punctuation">.</span>StartTagToken <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//get the token</span>
        token <span class="token operator">:=</span> tokenizer<span class="token punctuation">.</span><span class="token function">Token</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token comment" spellcheck="true">//if the name of the element is "title"</span>
        <span class="token keyword">if</span> <span class="token string">"title"</span> <span class="token operator">==</span> token<span class="token punctuation">.</span>Data <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">//the next token should be the page title</span>
            tokenType <span class="token operator">=</span> tokenizer<span class="token punctuation">.</span><span class="token function">Next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token comment" spellcheck="true">//just make sure it's actually a text token</span>
            <span class="token keyword">if</span> tokenType <span class="token operator">==</span> html<span class="token punctuation">.</span>TextToken <span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">//report the page title and break out of the loop</span>
                fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>tokenizer<span class="token punctuation">.</span><span class="token function">Token</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>Data<span class="token punctuation">)</span>
                <span class="token keyword">break</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>The <code>tokenType</code> returned from <code>tokenizer.Next()</code> will be one of their <a href="https://godoc.org/golang.org/x/net/html#TokenType">token type constants</a>. Here we check if it's a start-tag token, and if so, we then get the full Token struct. For all other token types, we don't even bother getting the full token, thereby saving memory allocations and processor cycles for initialization.</p><p>The token will have the tag name in its <code>.Data</code> field. Tag names are already converted to lowercase, so we can simply compare it against <code>"title"</code>. If it is the title element, we can then read the next token, which should be the element's text content. That's what we are after, so as soon as we get it, we print it and break out of the loop. Since this is the last code in the <code>main()</code> function, our program then exits.</p><h2 id="secrefactorthecode">Refactor the Code</h2><p>This works, but all of the code is in the <code>main()</code> function, which will make it difficult to add features or build upon this. As an exercise for the reader, refactor the code into several functions like this:</p><pre class="language-go"><code class="language-go"><span class="token comment" spellcheck="true">//fetchHTML fetches the provided URL and returns the response body or an error</span>
<span class="token keyword">func</span> <span class="token function">fetchHTML</span><span class="token punctuation">(</span>URL <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>io<span class="token punctuation">.</span>ReadCloser<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//TODO: put HTTP get code and error checking here</span>
    <span class="token comment" spellcheck="true">//return errors if GET fails, if response status code</span>
    <span class="token comment" spellcheck="true">//is != 200, or if Content-Type is not HTML</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">//extractTitle returns the content within the &lt;title> element</span>
<span class="token comment" spellcheck="true">//or an error</span>
<span class="token keyword">func</span> <span class="token function">extractTitle</span><span class="token punctuation">(</span>body io<span class="token punctuation">.</span>ReadCloser<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//TODO: put the tokenization code here, and return </span>
    <span class="token comment" spellcheck="true">//the page title or an error</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">//fetchTitle fetches the page title for a URL</span>
<span class="token keyword">func</span> <span class="token function">fetchTitle</span><span class="token punctuation">(</span>URL <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//TODO: fetch the HTML, extract the title, and make sure the body gets closed</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//if the caller didn't provide a URL to fetch...</span>
    <span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>Args<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">2</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//print the usage and exit with an error</span>
        fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"usage:\n  pagetitle &lt;url>\n"</span><span class="token punctuation">)</span>
        os<span class="token punctuation">.</span><span class="token function">Exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    title<span class="token punctuation">,</span> err <span class="token operator">:=</span> <span class="token function">fetchTitle</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>Args<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        log<span class="token punctuation">.</span><span class="token function">Fatalf</span><span class="token punctuation">(</span><span class="token string">"error fetching page title: %v\n"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">//print the title</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>title<span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre><p>By splitting the code into separate re-usable functions, we can easily add more features in the future, such as handling multiple URLs at a time.</p><h2 id="secgiveitawhirl">Give it a Whirl</h2><p>To run this program, execute these commands from within the <code>pagetitle</code> directory (Windows users should run <code>pagetitle.exe</code>):</p><pre class="language-bash"><code class="language-bash">go <span class="token function">install</span>
pagetitle http://google.com </code></pre><p>You should get back the value of the <code>&lt;title&gt;</code> element on the Google home page.</p><p>You can combine these in the Bash shell into one line, making it easier to re-compile and run after making changes:</p><pre class="language-bash"><code class="language-bash">go <span class="token function">install</span> <span class="token operator">&amp;&amp;</span> pagetitle http://google.com </code></pre><h2 id="secextendit">Extend It</h2><p>One you have it working, try extending this to handle multiple URLs passed as separate command-line arguments. Iterate over the <code>os.Args</code> slice starting at element <code>1</code>, pass each command-line argument to your <code>fetchTitle()</code> function, and print the result.</p></div></div></main><footer class="footer"><div class="container"><div class="content"><p>Created by <a href="https://ischool.uw.edu/people/faculty/dlsinfo">Dave Stearns</a>, <a href="https://ischool.uw.edu">The Information School</a>, <a href="https://uw.edu">University of Washington</a></p><p><a href=".."><span class="icon"><i class="fa fa-home"></i> </span>back to contents</a></p></div></div></footer><script>var headings=document.querySelectorAll("h2,h3,h4,h5");headings.forEach(function(e){var a=document.createElement("a");a.textContent="#",a.href="#"+e.id,a.classList.add("bookmark-link"),e.appendChild(a)})</script><script>!function(e,t,a,n,c,o,s){e.GoogleAnalyticsObject=c,e[c]=e[c]||function(){(e[c].q=e[c].q||[]).push(arguments)},e[c].l=1*new Date,o=t.createElement(a),s=t.getElementsByTagName(a)[0],o.async=1,o.src="https://www.google-analytics.com/analytics.js",s.parentNode.insertBefore(o,s)}(window,document,"script",0,"ga"),ga("create","UA-102177301-1","auto"),ga("send","pageview")</script></body></html>